# cgocopy Guided API Specification

## Goals
- Deliver a metadata-driven copy workflow that works once `cgocopy_metadata.h` is compiled into the CGO translation unit.
- Catch misuse early through validation with descriptive errors rather than allowing silent corruption.
- Keep runtime copy helpers fast by reusing cached registry mappings created during initialization.
- Provide a consistent single import path: `github.com/shivanshkc/cgocopy`.

## Scope
- Guided registration and copy APIs exposed by the `cgocopy` package.
- Metadata generated by the shipped `cgocopy_metadata.h` macros.
- Registry management helpers (reset, finalize, introspection) required by the guided flow.
- Support for string conversion through optional `CStringConverter` callbacks.

## Key Concepts
- **StructMetadata**: Opaque data supplied by the C side describing fields, sizes, offsets, and nesting.
- **Registry**: In-memory cache keyed by Go `reflect.Type` that stores validated `StructMapping` entries.
- **StructMapping**: Description of how to map C memory into a Go struct, including nested relationships.
- **CStringConverter**: Optional callback used to transform `char*` fields into Go strings.

## Public API (package `cgocopy`)
```go
// Registry bootstrap
func RegisterStruct[T any](conv CStringConverter) error
func Finalize()
func Reset()
func IsFinalized() bool

// Introspection
func GetMapping[T any]() (*StructMapping, bool)

// Copy helpers
func Copy[T any](dst *T, cPtr unsafe.Pointer) error
func CopyNoReflection[T any](dst *T, cPtr unsafe.Pointer) error
func FastCopier[T any]() (func(*T, unsafe.Pointer) error, error)
```

## Lifecycle
1. Include `cgocopy_metadata.h` alongside the C struct definitions.
2. Build with CGO so the metadata table and lookup function become visible to Go code.
3. At startup call `RegisterStruct` for every Go struct that will receive data.
4. After all registrations succeed call `Finalize` once to seal the registry.
5. Use `Copy`, `CopyNoReflection`, or `FastCopier` during runtime as needed.

## Validation Rules
- Registration fails if metadata for a struct (or any nested struct) is missing.
- Size and offset mismatches produce `ErrLayoutMismatch` with detailed field information.
- Duplicate registrations are ignored when metadata fingerprints match the existing mapping.
- Copy helpers require the registry to be finalized and surface `ErrRegistryNotFinalized` otherwise.

## Error Design
- All helpers return `error`; the package never panics for user mistakes.
- Sentinel errors: `ErrMetadataMissing`, `ErrStructNotRegistered`, `ErrRegistryNotFinalized`, `ErrRegistryFinalized`, `ErrLayoutMismatch`.
- Messages must reference the Go type and, when possible, the specific field that triggered validation failure.

## Converter Policy
- `CStringConverter` is optional during registration; `nil` selects the default UTF-8 converter.
- Converters apply to every string field captured by the registration, including nested structs registered separately.
- Copy helpers reuse the converter recorded at registration time.

## Registry Caching and Performance
- The package registry stores mappings in `map[reflect.Type]*StructMapping` protected by a mutex.
- Registrations precompute traversal plans so runtime copy helpers avoid reflection when possible.
- `FastCopier` returns a closure that performs the copy using the cached plan without additional allocations.

## Initialization Example
```go
cgocopy.Reset()
if err := cgocopy.RegisterStruct[User](nil); err != nil {
    return err
}
if err := cgocopy.RegisterStruct[Address](cgocopy.UTF8Converter); err != nil {
    return err
}
cgocopy.Finalize()

var out User
if err := cgocopy.Copy(&out, cPtr); err != nil {
    return err
}
```

## Migration Guidance
- Tests and documentation must reference `github.com/shivanshkc/cgocopy` instead of archived package paths.
- Legacy manual registries should delegate to the guided API until they can be removed.
- Projects migrating from bespoke flows should adopt `RegisterStruct` during initialization and drop direct metadata lookups.

## Open Questions
- Should the registry expose metrics or debug hooks for observing registration and copy activity?
- Do we need a configurable metadata symbol name for unconventional build setups?
- Would thread-safe copy helpers (without external synchronization) provide enough value to justify the overhead?
